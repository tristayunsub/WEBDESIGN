// 싱글톤을 쓰면 안되는이유!?
// 전역변수를 쓰면 안되는 이유랑 같다.

// 멀티 스레딩 환경에서는 심각하게 오류가 생길 수도 있고, 니가 만약 싱글톤 인스턴스 상태를 바꾸는 코드를 작성했는데, 
// 나중에 그게 오류를 일으키면 스크립트 하나하나 다 살펴봐야함

// 싱글톤을 사용하는 이유는 크게 두가지인데, 전역접근이랑 한개의 인스턴스만 존재해야하는 경우임. 
// 근데 이거 둘 다 필요한 경우는 사실상 없음. 그냥 지역변수로 하나 만들어서 쓰던가 아님 클래스 멤버로 쓰면 되거든.
//  애초에 전역접근 = 전역 변수 라는 뜻이니 위에서 말한 오류가 생기는거고

//  결론은 이렇게 많은 단점들을 감수하면서까지 싱글톤을 쓸 이유가 없음. 쓰지 말라는데는 이유가 있는법임

// 나는 주로 공용데이터 보관, 게임 전체에서 쓰이는 오브젝트들을 싱글톤으로 사용함. 각각 예시를 들어줄게/

// 1. 네가 게임을 만드는데 화면 상단에 항상 게임머니가 보이고, 게임머니로 상점에서 아이템을 사거나, 
// 강화를 하거나, 몬스터를 잡아서 게임머니를 얻는다 했을때, 게임머니를 싱글톤이 아니라 단순 객체로 생성해서 사용하면 상점 아이템 구매버튼 ,
//  강화버튼, 각 몬스터들이 전부 게임머니 객체를 참조하고 있어야 해. 그래야 접근해서 게임머니를 올리던가 내리던가 하니까. 
//  그러면 게임머니 관련 데이터 처리가 있는 클래스들은 전부 DI 구조를 가져야해.
//  그럴바에 그냥 PlayerResourceManager.Instance.currentMoney += 10.0f; 형식으로 하면 한 줄이면 끝나



// 2. 이번에도 게임을 만들자. 상점에서 아이템을 사는데 게임머니가 부족해. 그러면 게임머니가 부족하다고 팝업창을 띄워야할거야.
//  강화를 하다가 강화 재료가 부족해. 그럼 강화 재료가 부족하다 팝업창을 띄워야겠지? 이런식으로 하나의 오브젝트인데 여러곳에서 같이 사용되지만 
//  그 안의 내용물만 살짝 변할때(여기서는 골드가 부족합니다 or 재료가 부족합니다 같은 텍스트)는
//   싱글톤으로 객체를 만들면 편해. 
//  싱글톤으로 하지않는다면 1번과 마찬가지로 각 버튼들이 팝업창 오브젝트를 전부 가지고있거나, 참조하고 있어야해. 
// 생각해봐 각종 버튼들에 다 public GameObject popupOjbect; 써놓고 하나하나 다 드래그하면 시간 소비가 크겠지.

// 그럴바에 그냥 PopupManager.Instance.ShowPopUp("골드가 부족합니다",PopUpType.OneButton); 
// 이런 형식으로 안에 들어갈 텍스트와 팝업창의 형식(PopUpType은 enum임)을 매개변수로 넘겨줌으로써 간단하게 해결이 가능해

// 아주 가끔 게임의 메인로직을 싱글톤에 담는 경우도 있을수는 있는데 나는 그런건 지양하는 편이고, 이런식으로 여러군데에서 자주 사용되는 것들을 
// 싱글톤으로 구현해놓고 사용해.
//  이렇게 하면 나중에 다른 프로젝트를 만들때도 해당 싱글톤 클래스 or 싱글톤 클래스와 같이 만든 오브젝트를 
 
//  그냥 다른 프로젝트에 집어넣어서 PopupManager.Instance.ShowPopUp(); 
//  하고 편하게 재사용도 가능하지




1.디자인 패턴
각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 
세주벅인 구현 방안을 설계할때 참조할수 있는 전형적인 해결 방식

2.생성 패턴(Creational Pattern)
객체의 생성과 관련된 패턴
추상 팩토리 (Abstract Facotry): 구체적인 클랙스에 의존하지 않고,인터
페이스를 통해 서로 연관, 의존 하는 객체들의 그룹으로 생성하여 추상적으로 표현

빌더: 작게 분리된 인스턴스를 건축하듯이 조합하여 객체 생성

팩토리 메소드: 객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화한 패턴

프로토타입: 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴

싱글톤: 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만,
여러 프로세스가 동시에 참조할 수 없음

3.구조 패턴(Structural Pattern)
-클래스나 객체들을 조합하여 더 큰 구조로 만들수 있게 해주는 패턴
어댑터: 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록
변환해주는 패턴

브리지: 구현부에서 추상층을 분리하여, 서로가 독립으로 확장할 수 있도록 구성한 패턴

컴포지트: 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할때 사용하는패턴

데코레이터: 객체간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴

퍼싸드(fercade): 복잡한 서브클래스들을 피해 더 상위에 인터페이스를 구성함으로 써
서브 클래스들의 기능을 간편하게 사용할수 있도록하는 패턴

플라이웨이트:인스턴스가 필요할때마다 매번 생성하는 것이 아니고 가능한 한 공유해서
사용함으로써 메모리를 절약하는패턴

프록시: 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을
수행하는 패턴



4.행위 패턴(Behavioral Pattern)
-클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

책임 연쇄(chain of responsibility):요청을 처리할 수 있는 객체가 둘 이상 존재하여
한 객체가 처리하지 못하면 다음객체로 넘어가는 형태의 패턴

커맨드: 요청을 객체의 형태로 캡슐화 하여 재이용하거나 취소할수 있도록 요청에 필요한
정보를 저장하거나 로그에 남기는 패턴

인터프리터(Interpreter):언어에 문법 표현을 정의하는 패턴

반복자(Iterator):자료구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록하는 패턴

중재자(Mediator):수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여
객체로 정의하는 패턴

메멘토(Memento):특정 시점에서 객체 내부 상태를 객체화 함으로써 이후 요청에따라
객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴/ 되돌리기 기능을 개발할때
주로 이용

옵서버(Observer):한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게
변화된 상태를 전달하는 패턴

상태(state):객체의 상태에 따라 동일한 동작을 다르게 처리해야 할때 사용하는 패턴

전략(Strategy): 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호교환할 수 있게 정의하는패턴

템플릿 메소드(Template method): 상위 클래스에서 골격을 정의하고, 하위 클래스에서세부처리를
구체화하는 구조의 패턴

방문자(Visitor): 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는ㄴ패턴
/분리된 처리 기능은 각 클래스를 방문하여 수행
